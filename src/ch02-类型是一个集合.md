# 类型是一个集合

## ts到底在检测啥
在 ts 的世界里面，ts 主要静态检测的问题之一就是：**一个类型是不是另一个类型的子类型**。我们下面看一个最简单的例子

```ts
const status: number = 1
```

这里我们声明了一个变量 status，并且通过`:`的语法指明了它的类型是 number，最后给它赋了一个初值 1。

这里就隐藏着一个 ts 静态检测的过程。ts会检测1能不能赋给一个number类型的变量，这个过程就是在检验：**1是不是number的一个子类型**。如果1是number的一个子类型，那么这个语句就不会报错，反之就会报错。

我们可以把每个 ts 类型都可以想象成一个集合，上述的问题就变成了：**一个集合是不是另外一个集合的子集**。

## 什么是子集
什么是子集呢？我们说一个集合A包含了另一个集合B里面所有的元素，我们就可以说集合B是集合A的子集。

我们举个例子：

集合A有5个元素1，2，3，4，5

集合B有2个元素1，2



用韦恩图来表示就是：

图1

其中，集合A包含了集合B全部的元素（1和2），那么集合B就是集合A的子集

## 如何用集合来想象ts

还是回到最初的例子

```ts
const status: number = 1
```

'1'是一个数字，我们把它看做是一个集合，只不过它只有1个元素，数字'1'。

number也可以想象成一个集合，只不过它里面有无数个数字元素，里面可以有'1','2','3','4'等等。

而这个`const status: number = 1`这个赋值语句的类型校验是否正确，取决于：1这个集合是不是number这个集合的子集。

很显然，1是number这个集合的子集，那么ts会认为这段代码是没问题的。

我们接下来看一个错误的例子

```ts
const status2: number = 'some str' // error
```

'some str'是一个js字符串字面量变量，它也是有类型的，它的类型就是'some str'，我们也可以先看成只有一个元素的集合，但是很明显，'some str'不在number的集合中，因此'some str'不是number的子集，'some str'不是number的子类型，所以ts就报错了。

最后总结一下本章的内容：我们把ts中的类型想象成一个集合，而在赋值的操作中，只要满足：右边的值的类型（集合）是左边被赋值的类型（集合）的子类型（子集），ts的静态检查就不会报错。